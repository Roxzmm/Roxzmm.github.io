# Design Pattern


## Design Pattern {#design-pattern}

**设计模式**
[the relationship between design patterns](https:www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)


### Creational Patterns {#creational-patterns}


#### Factory Pattern {#factory-pattern}

工厂模式


#### Abstract Factory Pattern {#abstract-factory-pattern}


#### Singleton Pattern {#singleton-pattern}


#### Builder Pattern {#builder-pattern}


#### Prototype Pattern {#prototype-pattern}


### Structural Patterns {#structural-patterns}


#### Adapter Pattern {#adapter-pattern}


#### Bridge Pattern {#bridge-pattern}


#### Filter、Criteria Pattern {#filter-criteria-pattern}


#### Composite Pattern {#composite-pattern}


#### Decorator Pattern {#decorator-pattern}


#### Facade Pattern {#facade-pattern}


#### Flyweight Pattern {#flyweight-pattern}


#### Proxy Pattern {#proxy-pattern}


### Behavioral Patterns {#behavioral-patterns}


#### Chain of Responsibility Pattern {#chain-of-responsibility-pattern}


#### Command Pattern {#command-pattern}


#### Interpreter Pattern {#interpreter-pattern}


#### Iterator Pattern {#iterator-pattern}


#### Mediator Pattern {#mediator-pattern}


#### Memento Pattern {#memento-pattern}


#### Observer Pattern {#observer-pattern}


#### State Pattern {#state-pattern}


#### Null Object Pattern {#null-object-pattern}


#### Strategy Pattern {#strategy-pattern}


#### Template Pattern {#template-pattern}


#### Visitor Pattern {#visitor-pattern}


### J2EE Patterns {#j2ee-patterns}


#### MVC Pattern {#mvc-pattern}


#### Business Delegate Pattern {#business-delegate-pattern}


#### Composite Entity Pattern {#composite-entity-pattern}


#### Data Access Object Pattern {#data-access-object-pattern}


#### Front Controller Pattern {#front-controller-pattern}


#### Intercepting Filter Pattern {#intercepting-filter-pattern}


#### Service Locator Pattern {#service-locator-pattern}


#### Transfer Object Pattern {#transfer-object-pattern}


### Principles {#principles}


#### Open Close Principle {#open-close-principle}

开闭原则：对扩展开放，对修改关闭。在程序需要扩展时，不能去修改原有代码，应当实现类似热插拔的效果。


#### Liskov Substitution Principle {#liskov-substitution-principle}

里氏代换原则：任何基类可以出现的地方，子类一定可以出现。只有当派生类可以替换掉基类，且软件的功能不受影响时，基类才能真正被复用。


#### Dependence Inversion Principle {#dependence-inversion-principle}

依赖倒转原则：针对接口编程，依赖于抽象而不依赖于具体。


#### Interface Segregation Principle {#interface-segregation-principle}

接口隔离原则：使用多个隔离接口，比使用单个接口要好。降低类之间的耦合度，降低依赖。


#### Demeter Principle {#demeter-principle}

迪米特法则（最少知道原则）：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。


#### Composite reuse Principle {#composite-reuse-principle}

合成复用原则：尽量使用合成/聚合的方式，而不是继承。

